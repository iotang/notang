# 第 3 周

## 流水线的冒险

### 结构冒险

在一个运算单元正在被占用时，又来一个东西要使用它。比如一条指令的 Instruction fetch 和另一条指令的 Data access 撞车。

怎么解决？直接等？时间代价太大。

像哈佛架构那样，把指令存储器和数据存储器分开？那就要加硬件。

### 数据冒险

- 不同的指令之间可能会有数据上的依赖。
- 比如一个指令的操作数是上一个指令的结果。

怎么解决？又是直接等？时间代价还是太大。

或者，直接提前延展？

![data_hazard_forwarding.png](../../assets/data_hazard_forwarding.png)

但是，这种方案没法应付所有的情况。比如这里。

![data_hazard_forwarding_bubble.png](../../assets/data_hazard_forwarding_bubble.png)

这里需要暂停一个时钟周期，否则会触发时间悖论。

不过还有一种方法，需要软硬件的协同。

```riscv
ld x1, 0(x31)				ld x1, 0(x31)
ld x2, 8(x31)				ld x2, 8(x31)
add x3, x1, x2		  ->	ld x4, 16(x31)
sd x2, 24(x31)		 /		sd x2, 24(x31)
ld x4, 16(x31)		-		add x3, x1, x2
add x5, x1, x4				add x5, x1, x4
sd x5, 32(x31)				sd x5, 32(x31)
```

### 控制冒险

不同的指令之间可能指令的控制流上的依赖，比如 RISC-V 的 B 型指令需要的那些符号位。

![control_hazard.png](../../assets/control_hazard.png)

一种方法是等；另一种方法是预测。

![control_hazard_prediction.png](../../assets/control_hazard_prediction.png)

## 流水线的实施

![pipelining_implementation.png](../../assets/pipelining_implementation.png)