# 第 2 章：关系模型

> 简单又优雅。

一个使用关系模型的数据库储存了一些关系；一个“关系”是包含行和列的表。

!!! caution "注意"
	关系 relation 指的是一张表，联系 relationship 指的是一些实体之间的关联。

## 基本结构

对于集合 $D_1, D_2, \cdots$，它们的关系 $r$ 是它们笛卡尔积 $D_1 \times D_2 \times \cdots$ 的一个子集。

### 属性 Attribute

每个属性都有其（值）域 domain。根据第一范式，属性的值需要是原子化的，也就是说不能是多个值组合起来。

所有的域里面都包含 null，虽然 null 总会让数据处理变得复杂。

### 关系模式 Relation Schema

关系模式描述了一个关系的结构，比如：

``Instructor-schema = (ID: string, name: string,dept_name: string, salary: int)``

现在有属性 $A_1, A_2, \cdots, A_n$，那么 $R = (A_1, A_2, \cdots, A_n)$ 称为一个关系模式；$r(R)$ 是在关系模式 R 下的一个关系。

### 关系实例 Relation Instance

关系实例是某个时候关系里面的数据的快照。

如果现在有元组 t，那么 $t[A]$ 代表元组 t 中名为 A 的属性的值。

### 关系的特性

- 无序
- 不重

### 码 Keys

为了让 K（$K \sub R$）成为关系模式 R 的超码（Superkey），它需要满足只用 K 里面的属性就可以唯一确定所有的元组。比如对于下面这个：

|id|name|gender|species|
|--:|:--|:--|:--|
|1|妙艾拉|女|魔幻假面喵|
|624|蒙洛卡|男|魔幻假面喵|
|993|皎华|女|月亮伊布|

让 $K = \{\mathrm{id}\}$ 可以，$K = \{\mathrm{name}\}$ 可以，$K = \{\mathrm{gender}, \mathrm{species}\}$ 也可以；但是 $K = \{\mathrm{gender}\}$ 和 $K = \{\mathrm{species}\}$ 都不行。

而其中，候选码（Candidate Key）是所有超码里面**极**小的那几个，也就是候选码的真子集不能再组成超码。所以 $K = \{\mathrm{gender}, \mathrm{species}\}$ 也是一个候选码。

主码（Primary Key）是用户选定的一个候选码，表示的时候要打一个<u>下划线</u>。比如我们可以让 $K = \{\mathrm{id}\}$ 变成主码，因为名字还是太容易重复了：

Comrade(<u>id</u>, name, gender, species)，这样。

此时我们拿来宝可梦图鉴 Pokédex(<u>species</u>, ...)，那么属性 ``species`` 叫做 Comrade 引用 Pokédex 的一个外码。Comrade 是参照关系（referencing relation），Pokédex 是被参照关系（rederenced relation）。参照关系中，外码的值必须在被参照关系中实际存在或为 
null，所以你不能把什么祖利兽加进 Comrade 里面，因为他不是宝可梦。