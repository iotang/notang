# 第 2 天：二进制基础

来自：《程序员的自我修养》

## 编译

主流编译器：gcc，Windows Compiler (cl.exe)，clang，……

对于 gcc：

hello.c + \*.h -(cpp)-> hello.i -(gcc)-> hello.s -(as)-> hello.o 

hello.o + \*.a + \*.so -(ld)-> ./a.out

## ELF 文件

`objdump -d *.o`

File offset：这一段在 .elf 文件中的偏移。

.data 段：已经初始化了的全局静态变量和局部静态变量。

.rotada 段：只读的数据（比如字符串常量）。

.bss 段：未初始化的全局静态变量和局部静态变量。

（C 语言编译器会把全局符号分成 strong 和 weak 两类：函数和初始化过的全局符号为 strong，没有初始化的全局符号是 weak。.bss 段存没初始化的那一部分。）

.comment 段：编译器的信息。

## 静态链接

### 空间与地址分配

- 扫描所有的输入目标文件，获得它们的各个段的各种属性。
- 收集所有目标文件中的符号定义和符号，引用到一个全局符号表。
- 合并所有段，并建立映射关系。

### 符号解析和重定位

- 以上一步收集的信息，读取输入文件中，段的数据和重定位信息，进行符号解析和重定位。

#### 重定位表

#### 符号解析

每个目标文件都可能定义了一些符号，也可能引用了定义在其他目标文件的符号。

重定位的时候，链接器会在全局符号表找到相应的符号进行重定位。

## 装载

- 可执行文件：
  - 是静态的
  - 预先编译好的指令和数据的集合
  - 在磁盘里面
- 进程：
  - 是动态的
  - 程序运行时候的一个过程
  - 在内存里面

每个程序跑起来后，会得到自己的一个独立虚拟地址空间（Virtual Addres Space）。32 位下的空间为 `0x0` 到 `0xffff ffff`。（所以 32 位下的指针大小是 4 个字节。）

### 装载方式

#### 全部装入

- 家里有矿啊？
- 所需内存大于物理内存……？

#### 动态装载

不要的模块丢到磁盘中。

##### Overlay（基本上被淘汰）

程序员自己控制程序的装载和卸载。（这很费程序员。）

##### 分页（Paging）

把内存和所有磁盘中的数据和指令按照“页”为单位进行划分。之后装载和操作就都是一页一页来的。

页的大小可以是 4 KiB，8 KiB，2 MiB，4 MiB 等。

### 进程的建立

- 创建一个独立的虚拟地址空间。
- 读取 ELF 文件头，建立虚拟空间和可执行文件的映射关系。
- 把 CPU 指令设置成可执行文件的入口地址，位于文件头。