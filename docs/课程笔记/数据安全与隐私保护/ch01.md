# 第 1 章：用户的认证

## 安全政策（CIA 模型）

- 保密性 Confidentiality：只有有权限的人才能访问数据。
- 完整性 Integrity：必须要有权限才能修改数据。
- 可用性 Availability：“用户说要有服务，于是就有了服务。”

## 安全原则

- 机制的经济性：让设计变得越简单越小越好。
- 保险机制：设计失效时也不会出现威胁（默认给“无权限”）。
- 完全的仲裁：所有访问都需要审查。
- 开放的设计：不以秘密设计保证安全性。
- 权限分离
- 最小权限原则：权限能不给就不给。
- 最小公共化原则：尽量避免提供多个对象共享同一资源的场景。
- 心理上的可接受性：最终这个系统要给人用。

## AAA

> 也不是天青刺客联盟。

- 验证 Authentication：你是谁？
- 授权 Authorization（Access Control）：你能干什么？
- 审计 Audit / Provenance：我要怎么限制你？

### 验证 Authentication

有三种主流的思想：

- 你知道的东西——用户名和密码
- 你到底是谁——生物特征
- 你有什么——二次验证、密钥卡、……

### 密码

应用：

- 登入到一个本地计算机
- 远程登录一个计算机
- 登录到网络
- 访问网站

```plain
Client -> Password -> Server
```

实际攻击可以对客户端、服务端和传递过程进行攻击。

- 窃听 Eavesdropping：利用客户端和服务端之间的不安全信道。
- 用户端欺骗：Login spoofing、shoulder surfing、keylogging
- 词典爆破
- 社工
- 弱密码爆破（猜测）
- 钓鱼网站 Phishing attacks
- 伪造网站 Website forgery
- 按键记录 Keylogging

#### 猜测攻击

- 攻击者找到密码所需要的猜测数
- 攻击者验证密码所需要的时间

### 密码熵 Password Entropy

我们知道信息熵长这个样子：

$\mathbb{E}(X) = - \sum_{x \in X} P(x) \log_2 P(x) = E(-\log_2 P(x))$，单位是比特。

对于密码的分布，我们使用它来算出“密码熵”。

NIST 指定的密码熵计算公式：

- 第 1 位：4 bit
- 第 2 位到第 8 位：2 bit
- 第 9 位到第 20 位：1.5 bit
- 第 21 位和以后：1 bit

不过我们应该找到一个更好的方法。密码 `Meowscarada908!` 和密码 `8oda0e!as9wrMac` 的熵肯定得不同。

### 弱密码

- 经常被当成默认密码的：`admin` `default` `guest` `123456`
- 词典里有的词组：`computer` `science` `iostream` `meowscarada` 什么的。
- 简单的替换：`f1re` `m055` `p@ssword` 等。
- 键盘上的排列：`qwerty` `dvorak` `$%^&*` 等。
- 另外一些常见的排列：`114514` `1919810` `19260817` `998244353` 等。
- 和你个人相关的信息：身份证号码、生日、电话号码、学号、所属组织、亲戚名字及生日、宠物名字及生日、磕的 CP 等。

### 避免弱密码

- 让密码的长度变长。
- 如果可以，使用随机密码。（不过如果没有一个密码管理器的话会很成问题。）
- 通过一些同时使用字母、数字和特殊字符的规则构造密码。
- 自己尝试爆破一下自己的密码看能不能挡住攻击。

## 保存密码

古老的 UNIX：把密码的哈希 H(password) 直接存到 `/etc/passwd` 里面。哈希函数是单向的，但是也可以直接爆破。

现代的 UNIX：

- `/etc/passwd` 仍然可以被所有用户读取。
- `/etc/shadow` 只能被 root 读取，里面存储d的不是 H(password)，而是 (r, H(password, r))，r 对于每个密码都是随机选取的；并且 r 是公开的。

## 信任路径 Trusted Path

信任路径可以防止诸如伪造登录页面一类的攻击。低权限的程序无论如何都抢不到高权限进程的时间片。一个例子是 Windows 上的 Ctrl + Alt + Del 出来的那个。

## 在危险的信道上传递密码

- 一次性密码
- 挑战回应认证：认证服务器还会给用户一个随机数，看用户这边的加密函数是否和服务器的相同。
- 零知识证明
